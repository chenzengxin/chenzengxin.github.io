{"meta":{"title":"This is Chenzengxin's personal page","subtitle":null,"description":null,"author":"Chenzengxin","url":"","root":"/"},"pages":[],"posts":[{"title":"海伦公式","slug":"HeronFormula","date":"2019-08-27T16:00:00.000Z","updated":"2019-08-28T14:17:24.363Z","comments":true,"path":"2019/08/28/HeronFormula/","link":"","permalink":"/2019/08/28/HeronFormula/","excerpt":"","text":"海伦公式 背景：相传这个公式最早是由古希腊数学家阿基米德得出的，而因为这个公式最早出现在海伦的著作《测地术》中，所以被称为海伦公式。中国秦九韶也得出了类似的公式，称三斜求积术。（百度百科） 表达式：S=√p(p-a)(p-b)(p-c) 描述 假设在平面内，有一个三角形，边长分别为a、b、c，三角形的面积S可由以下公式求得： p = (a+b+c)/2 p 为半周长 S = sqrt(p(p-a)(p-b)(p-c)) 求点到线的最短距离sharp1234567891011121314double dis = 0;double a, b, c;a = DistancePt2Pt(pt0, pt1);// 线段的长度b = DistancePt2Pt(pt0, pt);// Pt1到点的距离c = DistancePt2Pt(pt1, pt);// Pt2到点的距离#region 两点屏幕距离public double DistancePt2Pt(Vector3 pt0, Vector3 pt1)&#123; return Math.Sqrt(Math.Pow((pt0.X - pt1.X), 2) + Math.Pow((pt0.Y - pt1.Y), 2));&#125;#endregiondouble p = (a + b + c) / 2;// 半周长double s = Math.Sqrt(p * (p - a) * (p - b) * (p - c));// 海伦公式求面积dis = 2 * s / a;// 返回点到线的距离（利用三角形面积公式求高）","categories":[],"tags":[],"author":"Chenzengxin"},{"title":"C# Reflection","slug":"C# Reflection","date":"2019-08-26T16:00:00.000Z","updated":"2019-08-28T14:20:41.209Z","comments":true,"path":"2019/08/27/C# Reflection/","link":"","permalink":"/2019/08/27/C# Reflection/","excerpt":"","text":"定义 审查元数据并收集关於它的类型信息的能力,元数据(编辑后的基本数据单元)就是一大堆表，编译器会创建一个类定义表，一个字段定义表，一个方法定义表等,System.Reflection命名空间包含的几个类，允许你反射(解析)这些元数据的代码 Assembly 结构 Assembly由以下几部分组成：Assembly Manifest 包含assembly的数据结构的细节。下面列出了Manifest中的主要信息： Assembly名字 版本号 Assembly运行的机器的操作系统和处理器 Assembly中包含的文件列表 所有assembly依赖的信息 Strong Name信息Type Metadata 包含assembly中允许的类型数据。（前面提到过，class, interface，member, property等） 获取Assembly： Assembly.Load Assembly.LoadFile Assembly.LoadFrom Type对象的Assembly方法 使用反射获取类型 获取类型有两种方式： 利用实例对象去获取它的类型（通过调用System.Object上声明的方法GetType来获取实例对象的类型对象） 通过Type.GetType以及Assembly.GetType方法 Type: 表示类型声明：类类型、接口类型、数组类型、值类型、枚举类型、类型参数、泛型类型定义，以及开放或封闭构造的泛型类型。 官方示例 sharp1234567891011121314151617using System;using System.Reflection;class Example&#123; static void Main() &#123; Type t = typeof(String); MethodInfo substr = t.GetMethod(\"Substring\", new Type[] &#123; typeof(int), typeof(int) &#125;); Object result = substr.Invoke(\"Hello, World!\", new Object[] &#123; 7, 5 &#125;); Console.WriteLine(\"&#123;0&#125; returned \\\"&#123;1&#125;\\\".\", substr, result); &#125;&#125;/* This code example produces the following output:System.String Substring(Int32, Int32) returned \"World\".*/ 动态创建对象Assembly.CreateInstance:sharp123object[] param = new object[] &#123; true,(byte)1,(short)2,'A',3,4L, _float, 6.0,\"i'm a string\" &#125;;var instance1 = assembly.CreateInstance(\"MyLib.ClassA\", false, BindingFlags.Default, null, param, null, null);var instance2 = assembly.CreateInstance(\"MyLib.ClassA\", false, BindingFlags.Default, null, null, null, null); Activator.CreateInstance:sharp12var instance3 = Activator.CreateInstance(types[0], param);var instance4 = Activator.CreateInstance(types[0], null); 动态调用对象方法Type对象的 InvokeMember方法 MethodInfo对象的Invoke方法sharp1234var result = types[0].InvokeMember(\"ToString\", BindingFlags.InvokeMethod, null, instance1, null);Debug.Log(result);Debug.Log(instance2.GetType().GetMethod(\"FuncA\").Invoke(instance2,null));Debug.Log(instance2.GetType().GetMethod(\"FuncB\").Invoke(instance2, new object[] &#123;\"i'm args\" &#125;)); CLASSsharp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253namespace MyLib&#123; public class ClassA &#123; private bool _bool; private byte _byte; private short _short; private char _char; private int _int; private long _long; private float _float; private double _double; private string _string; public ClassA() &#123; &#125; public ClassA(bool _bool, byte _byte, short _short, char _char, int _int, long _long, float _float, double _double, string _string) &#123; this._bool = _bool; this._byte = _byte; this._short = _short; this._char = _char; this._int = _int; this._long = _long; this._float = _float; this._double = _double; this._string = _string; &#125; public string FuncA() &#123; return \"FuncA\"; &#125; public string FuncB(string args) &#123; return \"FuncB，args = \" + args; &#125; public override string ToString() &#123; return String.Format(\"my prop is &#123;0&#125;,&#123;1&#125;,&#123;2&#125;,&#123;3&#125;,&#123;4&#125;,&#123;5&#125;,&#123;6&#125;,&#123;7&#125;,&#123;8&#125;\", this._bool, this._byte, this._short, this._char, this._int, this._long, this._float, this._double, this._string); &#125; &#125;&#125;","categories":[],"tags":[],"author":"Chenzengxin"},{"title":"Hello World","slug":"hello-world","date":"2019-08-21T02:52:13.482Z","updated":"2019-08-21T02:40:36.852Z","comments":true,"path":"2019/08/21/hello-world/","link":"","permalink":"/2019/08/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"第一篇博文","slug":"第一篇博文","date":"2019-08-20T16:00:00.000Z","updated":"2019-08-27T14:02:40.773Z","comments":true,"path":"2019/08/21/第一篇博文/","link":"","permalink":"/2019/08/21/第一篇博文/","excerpt":"","text":"一级标题一级标题1. 21 2. 2024949 3. 333二级标题二级标题- s - author - fdf - bash duanluo duanluo sdfsdfs三级标题&lt;&gt; 字体 斜体文本 斜体文本 粗体文本 粗体文本 粗斜体文本 粗斜体文本 删除线带下划线文本 脚注我有脚注 [^EXP][^EXP]: 啦啦啦啦啦!!! 分割线 区块 区块引用 ABCDEFGSDSDSD SDSDSD 没想到吧 哈哈哈哈 第一项 嚄嚄sdsd fsdkfjskd 第二项 1$ hexo new \"My New Post\" codeprintf(); System.Out.println(&quot;HelloWorld&quot;) 函数咋就没高亮呢，差评 &lt;?php echo &apos;HelloWorld&apos;; function test(){ echo &apos;test&apos; }123$(document).ready(function()&#123; alert(\"hello\");&#125;) 高亮好评 1234public static void main(String[] args)&#123; System.out.println(\"helloworld\");&#125; link我是一个链接 or just a https://www.baidu.com image12![alt 属性文本](图片地址)![alt 属性文本](图片地址 \"可选标题\") 表格 表头 表头 单元格 单元格 单元格 单元格 左对齐 右对齐 居中对齐 e e e e e e 支持HTML元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，如：使用 Ctrl+Alt+Del 重启电脑 转义\\ 反斜线` 反引号* 星号_ 下划线{} 花括号[] 方括号() 小括号# 井字号+ 加号- 减号. 英文句点! 感叹号 Math$$\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix}\\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\end{vmatrix}$$","categories":[],"tags":[],"author":"Chenzengxin"}]}